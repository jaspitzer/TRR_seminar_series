---
title: "Data Structures and Data Wrangling - TRR259 seminar Session 1"
author: "JS"
format: 
  html:
    self-contained: true
    toc: true
    toc-depth: 4
    df-print: paged
    grid: 
      body-width: 1200px
editor: visual
---

This document is meant as an addition to the Seminar Series on Data Analysis within the TRR259 in 2025. It is the companion document for the first Session. All materials can be accessed on the the [github](https://github.com/jaspitzer/TRR_seminar_series) repository.

In the first part, we will repeat the basic data structures of R. This is fairly technical, but is the necessary groundwork for more interesting things to come. Feel free to refer back to it at any point. Similarly, you can find another document like this on the github called basic_R.html walking you through the very basics.

In the second part, we are exploring the tidyverse with a focus on dealing with tables and spreadsheets. We will add and subtract columns, arrange and access specific parts of the tables to get to the information that we want.

Lastly, we will generate summary tables of a fictitious study cohort using the gtsummary package.

# Data structures

Apart from variables (valuers stored in R under a certain name), there are 5 data structures in R:

-   vectors

-   factors

-   matrix

-   data frames

-   lists

## Vectors

A way to store multiple values in R is using a vector. Vectors are generated by [c]{.underline}oncatenating values with the `c()` function.

```{r}
c(120,360,600,840)
```

Like variable, you can store vectors under a certain name.

```{r}
ages <- c(120,360,600,840)
```

VThese values can then be accessed using that same name again:

```{r}
ages
```

We can now use our `ages` vector to take a closer look at it. To see how many values are in `ages`, we can use the `length()` function. We can access any specific value in `ages` using square brackets "\[\]". We can also access multiple values at the same time by supplying a vector of positions.

```{r}
length(ages)
ages[3]
```

Vectors of numbers can be generated the same way as other vectors using `c()`, or generated using `:`.

```{r}
ages[c(1,2)] # accesses values in the first and second position
ages[3:5] # accesses values in positions 3, 4, and 5 
```

We can also not select specific positions:

```{r}
ages[-3] # accesses everything but the third position
```

We can do calculations with `ages` all at once:

```{r}
ages # just ages
ages + 5 
ages / 60
```

We can compare all ages in `ages` to something else:

```{r}
ages > 480
```

This returns a `TRUE` or`FALSE` for every value in ages. We cann aggregate them using `sum()`, where every `TRUE` is treated as 1 and every `FALSE` is treated as zero:

```{r}
sum(ages > 480) # this answers the questions: how many values are larger than 480
```

We can use `ages` to calculate a mean from it.

```{r}
mean(ages)
```

## Factors

This is a specialized version of a vector oftentimes used to store categorical data. It consists of the underlying vector of values and a separate argument called levels, which represents the different values in the factor.

```{r}
f  <- factor(c("C", "C", "C", "A", "A", "A"),
             levels = c("A", "C"))

sort(f)
f <- relevel(f, "C")

sort(f)
```

## Matrix

Matrix is a rectangular data structure. It is very good at handling very, very large amounts of data in an efficient fashion., but we will only work with it in very limited capacity. A matrix can be subset using `[]` for rows (before the comma) and columns (after the comma). Both rows and columns can have names and can be accessed using the names.

```{r}
m <- matrix(1:20, nrow = 5)
m
m[1,]
m[,1]
colnames(m) <- c("a", "b", "c", "d")
m
rownames(m) <- c("v", "w", "x", "y", "z")
m

m["x", "a"]
```

## Data Frame

The data frame is the work horse of our analyses. Like the matrix, it is a rectangular table, has rows and columns and is used to store most of the data we care about.

Similarly to the matrix, a data frame can be subset using `[]`. In addition, columns can be accessed using the `$` operator. The `summary()` function can give a brief overview of a data frame.

```{r}
set.seed(259)
df <- data.frame(diagnosis = rep(c("CTRL", "AAA"), each = 5), 
                 diameter = c(rnorm(5, 5, 0.5), 
                              rnorm(5, 2, 0.1)),
                 age = round(runif(10, 45, 80)))
df

df[,1]
df$diameter
summary(df)


df$diagnosis <- as.factor(df$diagnosis)

summary(df)
```

## List

Lists are a way to store diverse types of data. It will become more important in the second session, but here you are introduced to an example.

Lists can be subset using `[[]]`. Note that this is a double bracket. Single brackets return a list, not the elements of a list. A list has a defined `length()` like a vector and can be summarized with the `str()` function (str standing for structure.

```{r}
examples <- list("a", c("c", "example"), df)
examples[[1]]


examples[1:2]


length(examples)
str(examples)

```

### Named lists

Lists can also have each individual element named and can be accessed using the names.

```{r}
ducks <- list(number_of_ducks = 3,
              duck_names = c("Tick", "Trick", "Track"),
              duck_info = df)
ducks[[1]]
ducks[["duck_info"]]
ducks$duck_names
```

# Data wrangling and the tidyverse

Throughout this session and this course, we will be making extensive use of the `tidyverse` family of functions. If you have not yet done so, you can install them using the `install.packages()` command as explained in the the *Basic R* document.

```{r}
#| eval: false
install.packages("tidyverse")
```

We will, in this session and the next one, go through the packages and functions. All of the packages and their functions can be accessed with the `library()` function:

```{r}
library(tidyverse)
```

The packages contained in the `tidyverse` are created for the handling of data, with a focus on consistency and legibility, as a form of grammar for data. To explore their potential, we will need some data. In the [github for this course](https://github.com/jaspitzer/TRR_seminar_series), you will find a folder called *data*, containing two subfolders with data in them. Both contain their own data sets:

## Reading in data with readr

The aneurysm survey is a small example data set, generated by me, containing 900 patients, their aortic diameter in 2 positions as well as some additional information on the patients, including sex, age and potential co-morbidities.

The expression data is taken from the [airway](https://bioconductor.org/packages/release/data/experiment/html/airway.html) R package, containing RNA Seq expression data from airway smooth muscle cells with and without steroid treatment. It will come to heavy use later in the course, but will also make an appearance in this session. The data set is split into two files, one containing the actual expression data for each sample and one annotation detailing which condition each sample is associated with.

The first functions we're going to use are form the [readr](https://readr.tidyverse.org/) package, reading in our example data. This includes the path to the files. If you downloaded the complete folder from the github, you can put it in your working directory and use the same path as below, but the specifics might vary for your system. We read in the data using the `read_tsv()` function, as it is a tab-separated txt file, a very common file format.

```{r}
#| eval: false
library(tidyverse)
aa_data <- read_tsv("data/aneurysm_survey/example_data.txt")
aa_data
```

```{r}
#| echo: false
library(tidyverse)
aa_data <- read_tsv(here::here("data/aneurysm_survey/example_data.txt"))
aa_data
```

In the folder, the same data is contained multiple times in different formats. All these formats can be used like below.

Since we are in Germany, the .csv format is a bit of a complicated issue: the German convention is to use a comma "," for the decimal point, making the use of a comma-separated file difficult. For this purpose, both the `read_csv()` and `read_csv2()` functions exist, the latter accommodating the German speciality. Personally, I avoid csv files whenever I can, for precisely the reasons exemplified here. Similarly, you can store data in excel files, which can be very convenient, but comes with some issues.

Excel can modify the actual data, overwriting what was present and has a history of for example [converting gene names to dates](https://www.nature.com/articles/d41586-021-02211-4). It is generally unavoidable as a software, especially when working with clinicians, but you should not store your data in an excel format if you can avoid it at all. Part of the tidyverse, but not readr, is the `read_xlsx()` function from the [readxl](https://readxl.tidyverse.org/) package. We can access it without using the `library()` command using the `package::function()` shorthand. This is recommended when only single functions from a package are being accessed.

All of the the following code generates the same data frame as the example above.

```{r}
#| eval: false
aa_data <- read_csv("data/aneurysm_survey/example_data.csv")
aa_data <- read_csv2("data/aneurysm_survey/example_data2.csv")
aa_data <- readxl::read_xlsx("data/aneurysm_survey/example_data.xlsx")
```

Now that we have our data, we can take a quick look using the `glimpse()` function.

```{r}
library(tidyverse)
glimpse(df)
```

We see that the data consists of 9 columns and 900 rows. We also learn the name of the columns and some examples of values.

## Data wrangling with dplyr

With data and a first idea what to expect, we can dive into the first group of functions from a major tidyverse package, [dplyr](https://dplyr.tidyverse.org/). We will take a look on the following functions:

-   `mutate()` to create new columns

-   `selecet()` to select variables based on their names or position

-   `filer()`Â to filter our observations based on their values

-   `summarise()` to generate summary statistics based on multiple values

We will start by making a copy of our data, since we want to keep the original intact.

```{r}
df <- aa_data
```

### mutate()

We learned above that we have 900 patients, but no identifier for the patients, so using `mutate()`, we can add one. Here we use the `paste()` function to combine "Pat" simply with a counter from 1 to 900, and save it in the *patient* variable.

```{r}
df <- mutate(df, patient = paste("Pat", 1:900, sep = "_"))
```

Let's take a look:

```{r}
glimpse(df)
```

The new column has been added to the end. If we want it to instead be at the front, we can instead do the following:

```{r}
df <- aa_data # fresh start
df <- mutate(df, patient = paste("Pat", 1:900, sep = "_"), .before = 1) #the .before specifies the position
glimpse(df) # taking a look
```

We can also do some computations for the column we generate. We have an age column, and a brief inspection reveals that it probably is age in years. If we want months instead, we can just calculate this using the age column.

```{r}
df <- mutate(df, age_months = age * 12)
glimpse(df)
```

Things can also be more complicated: we can classify our patients based on their abdominal aortic diameter. Here, we'll use the `ifelse()` function. When you encounter something new, you can always run a question mark followed by the function in question, in this case `?ifelse()` to get some more information.

```{r}
df <- mutate(df, 
             severe_AAA = ifelse(abdominal_diameter > 5, # if an observation has an abdominal diameter larger than 5
                                 "severe",  # the new variable will classify them as severe
                                 "non_severe")) # if not, as non_severe
glimpse(df)
```

You can also do calculations with multiple columns

```{r}
df <- mutate(df, diameter_ratio = abdominal_diameter / thoracic_diameter)
glimpse(df)
```

When creating columns, you can overwrite existing columns by creating a "new" column with the same name. Let's say we want to flip that ratio:

```{r}
df <- mutate(df, diameter_ratio = thoracic_diameter / abdominal_diameter)
glimpse(df)
```

We can also round the results. For that, we can specify during creation, or just refer to the already generated column

```{r}
# these are equal
df <- mutate(df, diameter_ratio = round(diameter_ratio, 2)) 
df <- mutate(df, diameter_ratio = round(thoracic_diameter / abdominal_diameter, 2))
glimpse(df)
```

### filter()

Most of the time, not all observations (or patients) are relevant for the question at hand. To separate the ones that we care about for those we do not, we're going to use `filter()`. With our data frame, we can use conditions to get to the relevant observations. Let's say we only want patients who have been diagnosed with AAA:

```{r}
df <- aa_data
df <- filter(df, diagnosis == "AAA") # == is a comparison, = is assignment
glimpse(df)
```

What if we only want those with a truly wide aorta, lets say larger than 4.5 cm:

```{r}
df <- filter(df, abdominal_diameter > 4.5)
glimpse(df)
```

We can see, that only 87 observations remain.

These filtering steps can also be more complicated. If we want triple A patients who will be recommended surgery, but since it is an experimental procedure we want to exclude patients above the age of 75, we can also do that:

```{r}
df <- aa_data # fresh start
df <- filter(df, age < 75, # patients younger that 75
             abdominal_diameter > 4.5) # with an abdominal diameter larger than 4.5
glimpse(df)
```

We can also use the `|` (read: or) operator to get to all patients with a large diameter, independent of location:

```{r}
df <- aa_data
df <- filter(df, abdominal_diameter > 4 | thoracic_diameter > 4)
glimpse(df)
```

Only male patients, with coronary artery disease (cad) and without hypertension:

```{r}
df <- aa_data
df <- filter(df, male == 1, hypertension != 1, cad == 1)
glimpse(df)

```

In a query like above, it is sometimes of interest to know how many observations belong to each group. For that, we can use the `count()` function, while specifying what we should count.

```{r}
df <- aa_data
df <- filter(df, male == 1, hypertension != 1, cad == 1)
count(df, diagnosis)
```

We can see that the combination of factors is not equally distributed across the diagnoses. This is not a statistical test, but can be nice to know.

We can also filter for specific patients. In this example, this might be non-sensical, as we are also adding in the patient information, but it is easy to imagine a scenario where a query like this might be useful.

```{r}
df <- aa_data
df <- mutate(df, patient = paste("Pat", 1:900, sep = "_"))
df <- filter(df, patient %in% c("Pat_32", "Pat_565"))
glimpse(df)
```

### select()

We covered how you can filter the observation based on their values, but it is rare that all the variables are of interest. You can select a subset of columns using `select()`.

We can specify the columns that we want to retain.

```{r}
df <- aa_data
df <- select(df, diagnosis, abdominal_diameter, age)
glimpse(df)
```

We can also specify which columns we do not want.

```{r}
df <- aa_data 
df <- select(df, -age)
glimpse(df)
```

We do not need to refer to the columns by name, position is also allowed. This also works with negative selection.

```{r}
glimpse(df)
df <- select(df, 1:3)
glimpse(df)
df <- select(df, -c(1:2)) # note that you do need the c() here, otherwise it will generate an error
glimpse(df)
```

You can also use a column type (class) together is the `where()` function. This uses `where()` and `is.character()` to select only the columns of class character.

```{r}
df <- aa_data
df <- select(df, where(is.character))
glimpse(df)
```

Also works with numeric columns:

```{r}
df <- aa_data
df <- select(df, where(is.numeric))
glimpse(df)
```

These can be combined as desired

```{r}
df <- aa_data
df <- select(df, diagnosis, where(is.numeric))
glimpse(df)
```

### Interlude: the pipe %\>% or \|\> 

Writing code can fairly easily lead to da convoluted mess. The code below does a couple of things, none of which are particularly complicated. It filter die data frame on only AAA patients, adds a new variable using the diameter, then filter the data set based on the new variable as well as age.

```{r}
df <- aa_data
df <- filter(mutate(filter(df, diagnosis == "AAA"), 
                    operation = ifelse(abdominal_diameter > 4.5, 
                                       "operation", 
                                       "monitor")),
             operation == "operation", age < 75)
glimpse(df)
  
```

The code below does the same thing.

```{r}
df <- aa_data %>% 
  filter(diagnosis == "AAA") %>% 
  mutate(operation = ifelse(abdominal_diameter > 4.5,
                            "operation", 
                            "monitor")) %>% 
  filter(operation == "operation", age < 75)
glimpse(df)
```

This achieved through use of the so called *pipe*, which can be typed as `%>%` or `|>`. If you are using RStudio, `Ctrl` + `Shift` + `M` inserts it (`Cmd` + `Shift` + `M` on MacOS). It takes the output of a line of code and inserts it as the input to the next line of code. The following 2 lines are equivalent.

```{r}
#| eval: false
select(df, diagnosis)
df %>% select(diagnosis)
```

This works particularly well in the tidyverse, where the first input to functions is always the data.

This concept is both popular and controversial. Purists will tell you that people piping everything will never learn to code properly and evangelists will say that codes without pipes is needlessly difficult to read and understand. Your mileage may vary. An important thing to note is that piping is inherently inefficient from a resources point of view. Please be careful when using the pipe in the context of millions of rows and/or columns.

### summarize() and group_by()

We have now learned how to add columns, filter observations and select the variables of interest. We'll keep on using these tools throughout the next sessions as the backbone of everything we do. Before we move on from the dplyr family, we still have to meet to more workhorses of the package: `summarise()` and `groupy_by()`.

`summarise()` allows you to perform summary statistics and other computations taking in more than one value. If, for example, you want to calculate the mean or median of a certain variable, you would use `summarise()`.

```{r}
aa_data %>% 
  summarise(mean_abdominal_diameter = mean(abdominal_diameter))
```

```{r}
aa_data %>% 
  summarise(median_age = median(age),
            mean_age = mean(age),
            sd_age = sd(age))
```

On their own, these calculations are fairly simple and easily doable in both base R and something like Excel, but it gets more interesting once you add `group_by()`. This allows you to create groups within your data and to calculate the statistics for each group separately. In the example below, we calculate the mean for each diagnosis separately.

```{r}
aa_data %>% 
  group_by(diagnosis) %>% 
  summarise(mean_abdominal_diameter = mean(abdominal_diameter))
```

This applies to multiple calculations as well:

```{r}
aa_data %>% 
  group_by(diagnosis) %>% 
  summarise(median_age = median(age),
            mean_age = mean(age),
            sd_age = sd(age))
```

We can also group by more complicated things like cutoffs for variables. If we want to know if the mean BMI between AAA patients with an aneurysm larger than 4.5 is different from those with a smaller diameter, we can do so

```{r}
aa_data %>% 
  filter(diagnosis == "AAA") %>% # filter for AA patients only
  group_by(abdominal_diameter > 4.5) %>% # group by the relevant cutoff
  summarise(mean_bmi = mean(bmi),
            sd_bmi = sd(bmi))
```

### arrange(), slice_min() and slice_max()

Sometimes, you want to know, what the highest values or lowest values in your data set are, or you want to subset on the top 10 based on some metric. For this purpose, we have three tools: `arrange()` to reorder the rows of you data set based on a column of choice, `slice_max()` filters out the top X rows based on a column of choice, and `slice_min()` does the opposite.

By default, `arrange()` sorts ascending. So if we want the data frame arranged by the abdominal diameter, we can run:

```{r}
aa_data %>% 
  arrange(abdominal_diameter) %>% 
  head(10)
```

To change this, simply attach a "-" before the variable of choice:

```{r}
aa_data %>% 
  arrange(-abdominal_diameter) %>% 
  head(10)
```

If we only want a subset of rows, we instead can use `slice_min()` or `slice_max()`. To use it, we supply the data frame and avariable we want to order by, as well as N, the number of rows we want.

```{r}
aa_data %>% 
  slice_max(abdominal_diameter, n = 3)
aa_data %>% 
  slice_min(abdominal_diameter, n = 3)
```

## Data wrangling with tidyr

Once we have the basics down, we can move on to more complicated operations. For that, we will start be reading in the other example data, namely an expression data set:

```{r}
library(tidyverse)
counts <- read_tsv(here::here("data/expression_data/counts.txt"))
annotation <- read_tsv(here::here("data/expression_data/annotation.txt"))
```

```{r}
head(counts)
```

```{r}
annotation
```

### pivot_longer() & inner_join()

In the `counts`, we have the first column as the gene symbol, and the other columns as the different samples. Our samples are further described in the `annotation`, where we find the sample name in the *Run* variable. In order to combine this information, we will need to do some data reshaping: we want to have all the samples as a column, so that for each row we can add the relevant group annotation (for our case here whether or not the sample was treated with dexamethasone, save in the column *dex* in `annotation`). For that, we will need two things: `pivot_longer()` and *`inner_join()`.*

We will start with `counts` and `pivot_longer()`. This reshapes from its current wide format to a longer format: we lose columns and gain rows, without losing any information.

```{r}
head(counts) # quick look at how the data looks
counts_long <- counts %>% pivot_longer( # take the data and pivot longer
  cols = -gene, # select the columns to pivot longer, here everything but the gene column (similar to select)
  names_to = "sample", # put the column names into a new column called sample
  values_to = "count" # put the corresponding values ion a new column called count
)
head(counts_long)
```

The data frame still contains all the original information, just the organisation has changed.

Taking this data frame, we can now add the annotation information to it. This information currently is stored in `annotation`. We will first select the relevant columns from `annotaiton`, namely *Run* containing the sample name, *dex* containing the dexamethasone information, and *cell*, indicating the cell line of origin.

```{r}
anno_filtered <- annotation %>% 
  select(Run, dex, cell)
anno_filtered
```

With this new annotation, we will now merge it into the expression data. We will use `inner_join()`, a function from the dplyr package. It creates new columns with the data given, sorting it into an existing data frame base on the `by` argument as supplied. For more information, check out `?inner_join()`.

```{r}
df_long <- counts_long %>% 
  inner_join(anno_filtered, # join in the filtered annotation
             by = join_by(sample == Run)) # join it, using the sample information from the counts and the Run variable from the annotation
head(df_long)
```

We now have a data frame that contains all the information we want/need in `df_long`. Using the knowledge from the previous section, we can calculate the mean counts for a gene of interest (note: this is not how to handle RNA Seq data, but is done here for demonstration purposes).

```{r}
df_long %>% 
  filter(gene == "IL6") %>% 
  group_by(dex) %>% 
  summarise(mean_expression = mean(count))
```

### pivot_wider()

With our data in long format, we can do various things as demonstrated above. We can also re-transform it the data back into wide format; this does not necessarily mean the same shape and organisation as before. Here, we transform the data in such a way that we keep the samples and associated sample information as rows and instead move gene names to the columns.

```{r}
df_wide <- df_long %>% 
  pivot_wider(
    names_from = "gene", 
    values_from = "count"
  )
head(df_wide)
```

The important thing for this kind of transformation is that each observation and each value is always distinctive, ie.Â´you can always tell from which sample and variable a value is derived.

## Strings and writing with stringr

When we have our data in shape and organisation that we want to, we can do some interesting stuff with it. If we for example take the `long_df` we used in the previous section (I will regenerate it here for legibility):

```{r}
library(tidyverse)
counts <- read_tsv(here::here("data/expression_data/counts.txt"))
annotation <- read_tsv(here::here("data/expression_data/annotation.txt"))


counts_long <- counts %>% pivot_longer( # take the data and pivot longer
  cols = -gene, # select the columns to pivot longer, here everything but the gene column (similar to select)
  names_to = "sample", # put the column names into a new column called sample
  values_to = "count" # put the corresponding values ion a new column called count
)
anno_filtered <- annotation %>% 
  select(Run, dex, cell)

df_long <- counts_long %>% 
  inner_join(anno_filtered, # join in the filtered annotation
             by = join_by(sample == Run))
```

### str_detect()

With this data we look into genes in the data set. Please not again, that this is not a blueprint for RNA-Seq analysis, it is used as a dataset with a large amount of diversely named variables, namely genes.

Here we use `str_detect()` from the [stringr](https://stringr.tidyverse.org/index.html) package. It takes a string (computer speak for writing) as input and detects if a certain pattern is present

```{r}
library(tidyverse)
the_string <- "Hello, this is some writing"
str_detect(the_string, "Hello") # this will be true, sindde "Hello" is part of the string
str_detect(the_string, "Howdy") # this will be fales
```

we can combine this with `filter()` to filter out genes showing a consistent naming pattern, like mitochondrial genes. The genes start with "MT-", so we can use that as a pattern to only look at these genes, here combined with `group_by()` so that we get a mean per gene and treatment condition.

```{r}
df_long %>% 
  filter(str_detect(gene, "MT-")) %>% 
  group_by(gene, dex) %>% 
  summarise(mean_count = mean(count))
```

Similarly, we can use a simliar pattern in the interleukins, a family of immune mediators. They tend to start with "IL":

```{r}
df_long %>% 
  filter(str_detect(gene, "IL")) %>% 
  group_by(gene, dex) %>% 
  summarise(mean_count = mean(count))
```

If you look at the genes being filtered here, the pattern was insufficient, picking up genes like *AVIL* or *EMILIN1*. Using a special pattern indicating the start of the string, known a a regular expression or *regex*, we can make the pattern a lot more specific. This is more advanced stuff, but you can find an overview of various *regex* patterns [here](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf).

```{r}
df_long %>% 
  filter(str_detect(gene, "^IL")) %>% # the ^ indicates the start if the string
  group_by(gene, dex) %>% 
  summarise(mean_count = mean(count))
```

While not perfect, this approach excludes a lot more undesired genes.

Paging through the results above, you will notice genes containing the "-AS" pattern - this indicates antisense RNAs, not protein coding genes. You can exclude them using a similar approach. Here, the `!` in front of the `str_detect()` negates the pattern, excluding the results.

```{r}
df_long %>% 
  filter(str_detect(gene, "^IL"),
         !str_detect(gene, "-AS")) %>% 
  group_by(gene, dex) %>% 
  summarise(mean_count = mean(count))
```

### str_replace() and str_remove()

`str_detect()` can be very useful for filtering and the like, but there are two more workhorses in the stringr package: `str_replace()` and its special form, `str_remove()`.

This will be a lot more pressing once we get to plotting with its labels and text, but lets say we want to change the values for the *dex* column in `annotation`. We can use the `str_replace()` function for this. Checking out `?str_replace()`, we can learn that it expects 3 things: a string, a pattern and replacement; it then does what it says on the package, it replaces the pattern with the replacement. In the example below, we replace every occurence of "trt" in the *dex* column with "treated".

```{r}
anno_filtered
anno_filtered %>% 
  mutate(dex = str_replace(dex, "trt", "treated"))
```

If we want it a little more pretty, we can also add a "dexamethasone" to the start using `paste()`:

```{r}
df_long2 <- df_long %>% 
  mutate(dex = str_replace(dex, "trt", "treated"),
         dex = paste("dexamethasone", dex))
head(df_long2)
```

That seems a little long, and almost everyone understands it when you say "dexa", so lets trim it back a bit.

```{r}
df_long2 %>% 
  mutate(dex = str_remove(dex, "methasone")) %>% 
  head()
```

Another quick example: in our aneurysm survey, we have the *diagnosis* column with three values: CTRL, TAA, AAA.

```{r}
aa_data %>% 
  count(diagnosis)
```

Working in Germany, sometimes we have to bow to the German nomenclature in the clinic, where instead of abdominal aortic aneurysm it can be referred to as BAA, Bauch (meaning abdomen) aortic aneurysm. If we want to apply this to the data set, we can use `str_replace()` to do so.

```{r}
aa_data %>% 
  mutate(diagnosis = str_replace(diagnosis, "AAA", "BAA")) %>% 
  count(diagnosis)
```

# gtsummary and supplementary tables

One of the things you can with your data in R is to display them as tables. Imagine this in a supplementary of a paper, summarising your study cohort.

```{r}
library(tidyverse)
library(gtsummary)
# if its your first time running this, you will need to run install.packages("gtsummary")
aa_data %>% 
  select(-bmi) %>% 
  tbl_summary()
```

As a first shot, this doe snot look bad. What you see here is a summary table created using the [gtsummary](https://www.danieldsjoberg.com/gtsummary/index.html) package, more specifically the `tbl_summary()` function.

The diameter columns are treated as continuous variables, as is the age. The logical (0 / 1) columns of *age*, *hypertension*, *cad*, and *artheriosclerosis* are counted with a percentage indicating their relative occurrence. The labels do need a bit of work.

We can specify the labels using the labels argument and supplying a list of the structure `column_name ~Â "Text you want"`.

```{r}
aa_data %>% 
  select(-bmi) %>% 
  tbl_summary(label = list(
                abdominal_diameter ~ "Abdominal diameter",
                thoracic_diameter ~ "Thoracic diameter", 
                age ~ "Age",
                male ~ "Male", 
                hypertension ~ "Hypertension",
                cad ~ "Coronary artery disease",
                artheriosclerosis ~ "Artheriosclerosis"
              ))
```

That looks a lot better. However, we would like to split the cohort by their diagnosis, indicating any differences between them. For that we are using the `by = diagnosis` argument.

```{r}
aa_data %>% 
  select(-bmi) %>% 
  tbl_summary(by = diagnosis,
              label = list(
                abdominal_diameter ~ "Abdominal diameter",
                thoracic_diameter ~ "Thoracic diameter", 
                age ~ "Age",
                male ~ "Male", 
                hypertension ~ "Hypertension",
                cad ~ "Coronary artery disease",
                artheriosclerosis ~ "Artheriosclerosis"
              ))
```

The order of the columns is a bit harder than just fixing the labels, as we haven't covered the [forcats](https://forcats.tidyverse.org/) package yet. What you need to know is that the *diagnosis* column is treated as factor (see data structures above). By default, the levels are alphabetically, namely "AAA" before "CTRL". We are using the `fct_relevel()` to change the default order, setting "CTRL" as the first level.

```{r}
aa_data %>% 
  select(-bmi) %>% 
  mutate(diagnosis = fct_relevel(diagnosis, "CTRL")) %>% # releveling using the forcats package
  tbl_summary(by = diagnosis, 
              label = list(
                abdominal_diameter ~ "Abdominal diameter",
                thoracic_diameter ~ "Thoracic diameter", 
                age ~ "Age",
                male ~ "Male", 
                hypertension ~ "Hypertension",
                cad ~ "Coronary artery disease",
                artheriosclerosis ~ "Artheriosclerosis"
              ))
```

We cam also further customize the table by adding things like pValues and italicizing the labels.

```{r}
aa_data %>% 
  select(-bmi) %>% 
  mutate(diagnosis = fct_relevel(diagnosis, "CTRL")) %>% # releveling using the forcats package
  tbl_summary(by = diagnosis, 
              label = list(
                abdominal_diameter ~ "Abdominal diameter",
                thoracic_diameter ~ "Thoracic diameter", 
                age ~ "Age",
                male ~ "Male", 
                hypertension ~ "Hypertension",
                cad ~ "Coronary artery disease",
                artheriosclerosis ~ "Artheriosclerosis"
              )) %>% 
  italicize_labels() %>% 
  add_p()
```

# Summary

In this session, we have covered a lot of ground, and we were moving fast.

We have

-   read in data using readr functions, including `read_tsv()`

-   we have gone over the basics of data wrangling: `mutate()` to add columns, `filter()` to filter observations, `group_by()` and `summarise()` to compute statistics

-   on the more complicated end, we have merged data frames and transformed wide data into long data using `pivot_longer()`, and the reverse using `pivot_wider()`.

-   We have covered the generation of summary tables, a niche skill but a welcome addition to many papers.

I encourage you to go back over this document and the slides and, most importantly, to go over the practice questions below. You are acquiring a skill and that comes with practice. These drier bit are the necessary ground work for us to dive into visualization, mean separatation and statistics next session.

# Practise and questions

The follow ing are questions for you to practise what you learned so far. Feel free to go back through the document and the slides, but I would advise against using something like an LLM - this is where the learning happens.

## Easy

E1: Use the code below to generate a vector called `words`. Access the third value of `words`.

```{r}
words <- c("This", "is", "so", "so", "great")
```

E2: Use the `length()` function to get to the length of the vector. What is its length?

E3: What class is `words`?

Refer to the [github](https://github.com/jaspitzer/TRR_seminar_series) and download the data from the data folder. As a help you can check out the the basic_R.html file, download and open it.

E3: Read in the aneurysm survey data. How many rows does it have? How many columns? Use the `colnames()` function to receive the column names.

E4: Add a column to the data frame containing a specific label for each patient. Which patient is the oldest? Which patient has the smallest thoracic diameter? Does that patient also have hypertension?

E5: Using the same data, how many patients have a thoracic diameter larger than 3.5 cm? Hint: use the `filter()` function

E6: We do not need that much precision in the diameters we have. Round them to two decimal points.

## Medium

M1: What is the minimal aortic diameter in the AAA condition?

M2: What is the mean abdominal diameter in the data set?

M3: What is the mean abdominal diameter by diagnosis? Considering only patients older than 60, how does this change?

M4: If you consider the median instead of mean and thoracic diameter instead of abdominal, what are the results?

## Hard

H1: Refer back to the github and read in the expression data set. Merge them in the same fashion as above.

H2: Consider the gene *CXCL8*. What is the mean expression in the data set? What is the mean expression per treatment? What is the mean expression by treatment and cell line? Which sample shows the highest expression of *CXCL8*?

H2a: *CXCL8* is the gene name coding for the protein IL8. For your table, you want to replace the gene name with the protein name. Hint: use `str_replace()` and `mutate()`

H3: Generate an overview table of the aneurysm survey data using gtsummary.

H4: Split the table by diagnosis.

H5: Subset your study data to only include patients over the age of 50 and with a BMI larger than 22.
